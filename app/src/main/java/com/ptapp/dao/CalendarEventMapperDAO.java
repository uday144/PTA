package com.ptapp.dao;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;

import com.ptapp.provider.PTAppDatabase;

/** All CRUD(Create, Read, Update, Delete) Operations */
public class CalendarEventMapperDAO {
	private String TAG = "DS_CalendarEventMapper";

	// Database fields
	private SQLiteDatabase db;
	private PTAppDatabase dbHelper;

	/**
	 * To access the database, instantiate the subclass of SQLiteOpenHelper,
	 * i.e. PTAppDbHelper
	 */
	public CalendarEventMapperDAO(Context context) {
		dbHelper = new PTAppDatabase(context);
	}

	public void close() {
		dbHelper.close();
	}

	/*public int getRowsCount() {
		Cursor cursor = null;
		int count = 0;
		try {
			// Gets the database in read mode(open the database)
			db = dbHelper.getReadableDatabase();

			cursor = db
					.query(CalendarEventMapper.TABLE_NAME,
							new String[] { CalendarEventMapper.COL_NAME_ANDROID_EVENT_ID },
							null, null, null, null, null, null);
			count = cursor.getCount();
		} catch (Exception ex) {
			Log.e(TAG, ex.getMessage());
		} finally {
			cursor.close();
			db.close();
		}
		return count;
	}

	public long addEvent(CalendarEventMapperBean event) {
		long rowId = 0;
		try {
			// Gets the database in write mode(open the database)
			db = dbHelper.getWritableDatabase();

			ContentValues values = new ContentValues();
			values.put(CalendarEventMapper.COL_NAME_SERVER_EVENT_ID,
					event.getServerEventId());
			values.put(CalendarEventMapper.COL_NAME_EVENT_TYPE,
					event.getEvtType());
			values.put(CalendarEventMapper.COL_NAME_START_DATETIME,
					event.getStartDatetime());
			values.put(CalendarEventMapper.COL_NAME_END_DATETIME,
					event.getEndDatetime());
			values.put(CalendarEventMapper.COL_NAME_EVENT_TITLE,
					event.getEventTitle());
			values.put(CalendarEventMapper.COL_NAME_EVENT_DESCRIPTION,
					event.getEventDescription());
			values.put(CalendarEventMapper.COL_NAME_FOR_CLASSES,
					event.getForClasses());

			// Inserting Row
			rowId = db.insert(CalendarEventMapper.TABLE_NAME, null, values);
			if (-1 != rowId) {
				Log.i(TAG,
						"Event has been inserted in CalendarEventMapper tbl, with rowId: "
								+ String.valueOf(rowId));
			} else {
				Log.i(TAG, "Due to some errors, Event couldn't be inserted.");
			}

		} catch (Exception ex) {
			Log.e(TAG, ex.getMessage());
		} finally {
			db.close();
		}
		return rowId;
	}

	*//**
	 * @param event
	 *            - to update an event
	 * @return int - number of rows affected.
	 *//*
	public int updateEvent(CalendarEventMapperBean event) {
		int numOfRows = 0;
		try {
			// Gets the database in write mode(open the database)
			db = dbHelper.getWritableDatabase();

			ContentValues values = new ContentValues();

			values.put(CalendarEventMapper.COL_NAME_EVENT_TYPE,
					event.getEvtType());
			values.put(CalendarEventMapper.COL_NAME_START_DATETIME,
					event.getStartDatetime());
			values.put(CalendarEventMapper.COL_NAME_END_DATETIME,
					event.getEndDatetime());
			values.put(CalendarEventMapper.COL_NAME_EVENT_TITLE,
					event.getEventTitle());
			values.put(CalendarEventMapper.COL_NAME_EVENT_DESCRIPTION,
					event.getEventDescription());
			values.put(CalendarEventMapper.COL_NAME_FOR_CLASSES,
					event.getForClasses());

			// Updating Row
			String[] whereArgs = new String[] { event.getServerEventId() };
			numOfRows = db.update(CalendarEventMapper.TABLE_NAME, values,
					CalendarEventMapper.COL_NAME_SERVER_EVENT_ID + "=? ",
					whereArgs);

		} catch (SQLException ex) {
			Log.e(TAG, ex.getMessage());
		} finally {
			db.close(); // Closing database connection
		}
		return numOfRows;

	}

	public void updateAndroidEventId(long androidEventId, String serverEventId) {
		try {
			// Gets the database in write mode(open the database)
			db = dbHelper.getWritableDatabase();

			ContentValues values = new ContentValues();
			values.put(CalendarEventMapper.COL_NAME_ANDROID_EVENT_ID,
					androidEventId);

			// Updating Row
			String[] whereArgs = new String[] { serverEventId };
			db.update(CalendarEventMapper.TABLE_NAME, values,
					CalendarEventMapper.COL_NAME_SERVER_EVENT_ID + "=? ",
					whereArgs);

		} catch (SQLException ex) {
			Log.e(TAG, ex.getMessage());
		} finally {
			db.close(); // Closing database connection
		}
	}

	*//**
	 * Adds the event Id generated by android and event id passed by Server in
	 * the CalendarEventMapper table
	 *//*
	// TODO: need to check if, this method is in use anymore.
	// public void addToCalendarEventMapper(long androidEventId,
	// String serverEventId) {
	// try {
	// // Gets the database in write mode(open the database)
	// db = dbHelper.getWritableDatabase();
	//
	// ContentValues values = new ContentValues();
	// values.put(CalendarEventMapper.COL_NAME_ANDROID_EVENT_ID,
	// androidEventId);
	// values.put(CalendarEventMapper.COL_NAME_SERVER_EVENT_ID,
	// serverEventId);
	//
	// // Inserting Row
	// long insertId = db.insert(CalendarEventMapper.TABLE_NAME, null,
	// values);
	// Log.i(TAG,
	// "new row CalendarEventMapperId: "
	// + String.valueOf(insertId));
	// } catch (SQLException ex) {
	// Log.e(TAG, ex.getMessage());
	// } finally {
	// db.close(); // Closing database connection
	// }
	// }

	*//** Getting single row by providing server event id *//*
	public CalendarEventMapperBean getCalendarEventMapperByServerEventId(
			String serverId) {
		Cursor cursor = null;
		try {
			// Gets the database in read mode(open the database)
			db = dbHelper.getReadableDatabase();

			cursor = db.query(CalendarEventMapper.TABLE_NAME, null,
					CalendarEventMapper.COL_NAME_SERVER_EVENT_ID + "=?",
					new String[] { serverId }, null, null, null, null);

			if (cursor.moveToFirst()) {
				CalendarEventMapperBean cem = setCalendarEventMapperBean(cursor);
				return cem;
			} else {
				return null;
			}
		} catch (SQLException ex) {
			Log.e(TAG,
					"getCalendarEventMapperByServerEventId(): "
							+ ex.getMessage());
			return null;
		} finally {
			cursor.close(); // Closing the cursor
			db.close(); // Closing database connection
		}
	}

	// gets all the rows.
	public ArrayList<CalendarEventMapperBean> getAllEventMapperRows() {
		ArrayList<CalendarEventMapperBean> lst_CEM = new ArrayList<CalendarEventMapperBean>();
		Cursor c = null;
		try {
			// Gets the database in read mode(open the database)
			db = dbHelper.getReadableDatabase();

			c = db.query(CalendarEventMapper.TABLE_NAME, null, null, null,
					null, null, null, null);

			if (c.moveToFirst()) {
				do {
					CalendarEventMapperBean cem = setCalendarEventMapperBean(c);
					lst_CEM.add(cem);

				} while (c.moveToNext());
			}
		} catch (SQLException ex) {
			Log.e(TAG, "getAllEventMapperRows(): " + ex.getMessage());
		} finally {
			c.close(); // Closing the cursor
			db.close(); // Closing database connection
		}

		return lst_CEM;
	}

	// gets current month events.
	// yearMonth should be in format - "2014-06" without quotes.
	public ArrayList<CalendarEventMapperBean> getMonthWiseEvents(
			String yearMonth) {
		ArrayList<CalendarEventMapperBean> lst_CEM = new ArrayList<CalendarEventMapperBean>();
		Cursor c = null;
		try {
			// Gets the database in read mode(open the database)
			db = dbHelper.getReadableDatabase();

			String selectQuery = "SELECT * FROM "
					+ CalendarEventMapper.TABLE_NAME
					+ " WHERE strftime('%Y-%m', "
					+ CalendarEventMapper.COL_NAME_START_DATETIME + " ) = ?";

			c = db.rawQuery(selectQuery,
					new String[] { String.valueOf(yearMonth) });

			if (c.moveToFirst()) {

				do {
					CalendarEventMapperBean cem = setCalendarEventMapperBean(c);
					lst_CEM.add(cem);

				} while (c.moveToNext());
			}
		} catch (SQLException ex) {
			Log.e(TAG, "" + ex.getMessage());
		} finally {
			c.close(); // Closing the cursor
			db.close(); // Closing database connection
		}

		return lst_CEM;
	}

	*//**
	 * get all events which have not saved to calendar yet, means which has
	 * andriodEventId = null or 0 or ""
	 *//*
	public ArrayList<CalendarEventMapperBean> getEventsNotSavedToCalendar() {
		ArrayList<CalendarEventMapperBean> lst_CEM = new ArrayList<CalendarEventMapperBean>();
		Cursor c = null;
		try {
			// Gets the database in read mode(open the database)
			db = dbHelper.getReadableDatabase();

			c = db.query(CalendarEventMapper.TABLE_NAME, null,
					CalendarEventMapper.COL_NAME_ANDROID_EVENT_ID
							+ " is null or "
							+ CalendarEventMapper.COL_NAME_ANDROID_EVENT_ID
							+ " = ? ", new String[] { "" }, null, null, null,
					null);

			Log.i(TAG, "count of events not saved to calendar: " + c.getCount());
			if (c.moveToFirst()) {
				Log.i(TAG,
						"count of events not saved to calendar: "
								+ c.getCount());
				do {
					CalendarEventMapperBean cem = setCalendarEventMapperBean(c);
					lst_CEM.add(cem);

				} while (c.moveToNext());
			}
		} catch (SQLException ex) {
			Log.e(TAG, "getEventsNotSavedToCalendar(): " + ex.getMessage());
		} finally {
			c.close(); // Closing the cursor
			db.close(); // Closing database connection
		}

		return lst_CEM;
	}

	// gets latest events.
	public ArrayList<CalendarEventMapperBean> getLatestEvents(int numOfRows) {

		ArrayList<CalendarEventMapperBean> lst_CEM = new ArrayList<CalendarEventMapperBean>();
		Cursor c = null;
		try {
			// Gets the database in read mode(open the database)
			db = dbHelper.getReadableDatabase();
			String selectQuery = "select * from "
					+ CalendarEventMapper.TABLE_NAME + " where date("
					+ CalendarEventMapper.COL_NAME_START_DATETIME
					+ ") > date('now') LIMIT " + numOfRows;

			c = db.rawQuery(selectQuery, null);

			if (c.moveToFirst()) {
				do {
					CalendarEventMapperBean cem = setCalendarEventMapperBean(c);
					lst_CEM.add(cem);

				} while (c.moveToNext());
			}
		} catch (SQLException ex) {
			Log.e(TAG, "" + ex.getMessage());
		} finally {
			c.close(); // Closing the cursor
			db.close(); // Closing database connection
		}

		return lst_CEM;
	}

	*//**
	 * 
	 * Maps the values from cursor to CalendarEventMapperBean columns, then
	 * return the table object
	 * 
	 * @param c
	 *            - Cursor
	 * @return CalendarEventMapperBean
	 *//*
	private CalendarEventMapperBean setCalendarEventMapperBean(Cursor c) {
		CalendarEventMapperBean cem = new CalendarEventMapperBean();
		cem.setAndroidEventId(c.getLong(c
				.getColumnIndex(CalendarEventMapper.COL_NAME_ANDROID_EVENT_ID)));
		cem.setServerEventId(c.getString(c
				.getColumnIndex(CalendarEventMapper.COL_NAME_SERVER_EVENT_ID)));
		cem.setEvtType(c.getString(c
				.getColumnIndex(CalendarEventMapper.COL_NAME_EVENT_TYPE)));
		cem.setForClasses(c.getString(c
				.getColumnIndex(CalendarEventMapper.COL_NAME_FOR_CLASSES)));
		cem.setEventTitle(c.getString(c
				.getColumnIndex(CalendarEventMapper.COL_NAME_EVENT_TITLE)));
		cem.setEventDescription(c.getString(c
				.getColumnIndex(CalendarEventMapper.COL_NAME_EVENT_DESCRIPTION)));
		// cem.setCalId(c.getLong(c.getColumnIndex(CalendarEventMapper.)))
		cem.setStartDatetime(c.getString(c
				.getColumnIndex(CalendarEventMapper.COL_NAME_START_DATETIME)));
		cem.setEndDatetime(c.getString(c
				.getColumnIndex(CalendarEventMapper.COL_NAME_END_DATETIME)));
		return cem;
	}*/
}
